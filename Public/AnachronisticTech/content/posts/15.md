---
date: 29/07/2019
summary: With my tile puzzle game now having been in on-off development for just under a year, I decided it was finally time to implement the Android version on my own terms.
type: project
tags: psakse;kotlin;programming
---

# What have I been developing this month? - Psakse (Android & MacOS)

> "If at first you don't succeed..."

Those following my blog will know that I've been developing my own tile-based puzzle game, called Psakse, for the past nine months. As a novice programmer and game development enthusiast, Psakse was an experiment: could I come up with a decent idea for a tabletop game then implement it as video game for some platform? The first part is subjective, but the second was the important one. At the time I was also learning Swift for iOS development, so that was the platform I wanted to build for. When the app neared completion the first time, my friends requested an Android-compatible version, and that opened up a whole new world of trouble...

For iOS, Psakse was built using UIKit. Before anyone points out that UIKit is for UI, not games, I am currently in the process of rebuilding the game in SpriteKit. Regardless, since the board of the game stays mostly static, using button elements seemed like a good way of interacting with the game and 'placing' tiles by changing the visible properties of the button. Initially, I tried laying out the buttons in the grid using Xcode's Interface Builder tool, but this was such a complete pain to integrate with layout constraints and code that this first version of the app was scrapped about ten minutes in. After discovering I could build the UI procedurally using UIKit and positioning all the buttons absolutely on the screen using some ~clever~ simple maths, things became much simpler, and now the whole project is built this way. The only use of Interface Builder now is to manage transitions between different view controllers for different parts of the app.

The situation on Android is a little different. As far as I can tell, there isn't an analogue for UIKit. Though you can use the android.widget library for UI elements, Android developers much prefer using XML and Android Studio's layout designer to build a user interface for each activity or view. This seemed less than ideal since this was exactly the problem that UIKit had let me sidestep for iOS. The last thing I wanted was to have to draw out a UI in XML. What if later down the line I wanted to add different size boards? Building the layout in XML seemed both painful and inextensible, so I dropped the project pretty much as soon as I started. From where I was standing, the iOS version was still in need of improvements and a code cleanup.

> "No place like home"

Fast-forward three months, the iOS version of Psakse was now looking much more polished. It was still not perfect, but functioned as a game I could casually play on my phone. Requests from friends for an Android version continues, so I decided it was time to give it another bash. Remembering my experience with the layout creator, I resolved to build the app purely procedurally like its iOS counterpart. It occurred to me that, since I had written the original version in Swift, it might be easier to build the Android version in Kotlin rather than Java. Despite the fact that I knew more Java than Kotlin, Kotlin seemed the better choice due to it similarities with Swift; in particular, the presence of optionals and algebaic data types greatly appealed to me since they had made the Swift version much easier and neater to code.

What I hadn't counted on was how much Android developers seem to be more inclined to use XML rather than procedural code for UI. I can understand why; keep the logic in the code and keep the UI filed away somewhere else. Though it made sense on some level, it was still frustrating to search online for how to do something in Java or Kotlin and the top three answers tell you how it's done in XML. I managed to implement most of the non-UI parts without difficulty, but when it came to drawing stuff on the screen I just encountered brick wall after brick wall. I declared round two a failure and got back to doing something more productive.

> "Third time lucky"

Three months after my second failed attempt, I decided to revisit Psakse for iOS after my university exams were over. I learned a lot from my studies and decided to put some of it into practice by reworking Psakse. After a couple of days on-and-off coding, Psakse was looking in its best ever shape! You can read about the improvements here ()[], but to summarise, there was a newly implemented challenge mode with JSON-powered puzzles from a server, the code was now split over multiple small files for ease of management, and a lot of the junk code that could be removed or refactored was removed or replaced with something better. I was really pleased with the result as this seemed like the first time where I could contemplate adding a new feature without rebuilding from scratch again.

At this stage, a friend of mine had finally convinced my to try programming in Dart with the Flutter framework for cross-platform app development. His goal was to get me to build Psakse in Flutter so that he could finally get the Android version I had declared was not happening any time soon. It was a good idea; a single codebase for multiple platforms would lead to centralised updates, and I would have my iOS version of the game while my friends would at last have an Android version. The downside was that Flutter uses a declarative UI approach where you build a tree of views to create a user interface. I get why this is a good idea for most apps, but like Interface Builder in Xcode, and Layout Creator and XML in Android Studio, I didn't believe Flutter's UI approach was the most suitable for Psakse. We toyed around with Flutter for about a week, but it failed to grab my attention for the purpose of Psakse. I'll likely revisit Flutter for future non-game cross-platform apps I develop.

With the iOS version mostly complete, and the Flutter version dead in the water, I took a step back to consider options for a possible Android version. The first - and arguably simplest - option was to forget about it; my project, my rules, and an Android version was never in the project scope. Though true, this option felt unsatisfying, so I fell back to option two: build Peaks for Android in Kotlin procedurally. This was likely to result in headaches like the last time, but I had two significant advantages this time round. First, my Swift code had been neatly refactored so I could just translate most of it to Kotlin, and second, I had stumbled upon an article online about building procedural Android UI in Java which proved it did work quite well! I cracked open Android Studio, updated everything, and got to work translating each Swift source file into a Kotlin source file. Most of the files were easy; it was only when I reached the classes that control the grid and the gameplay that the complexity increased.

The Android widgets library is no UIKit, but it became a little easier to work with when I realised most of the XML properties available to each widget had procedural counterparts. Now that I knew what I was looking for, solutions online became much easier to search and find, and I made more progress in two days than I had in all my other attempts at an Android port combined. The biggest challenges were layouts and how colour is handled in Android. The issue with layouts was that Android prefers the LinearLayout and RelativeLayout types that work well with XML. The idea is that a developer specifies the UI elements in XML, and the device handles positioning and sizing automatically. This wouldn't work for me since I had already calculated the exact size and position of every element being displayed, so I needed a way to tell Android "put this thing at this coordinate and make it this big." After a false start with the now-depreciated AbsoluteLayout, I found exactly what I needed in the FrameLayout widget which lets the developer control the UI positioning and sizing with pixel precision.

As for how Android handles colour, I'll issue a warning now: this was the biggest source of headache, and pretty much perfectly exemplifies why I dislike developing for Android. If you don't like rants, this paragraph is not for you. In UIKit, I used the UIColor type to specify all my colours. This worked well since I could pass colours around my code as I pleased, and easily convert them to the CoreGraphics library version using the .cgcolor method at any point. Colours were specified in RGBA mode, so naturally I looked for the Android equivalent. As expected, Android has its own Colour type with a constructor for RGBA. However, this constructor is only available in API level 26 and higher. My project was set to level 22. 'No problem,' I thought, 'I'll just find a constructor for API 22.' Except there isn't one. To my horror I discovered that - until API 26 - there was no way to declare colours programmatically other than in hexadecimal mode with no transparency. While converting the code was not difficult, I found myself wondering why Android had left it so late to implement RGBA constructors.

With the hex colours in place, I reloaded the app onto the simulator, and was surprised to find there were no colours! Only after about an hour or two ~of cursing under my breath~ did I come across a post on stackOverflow explaining that the colours had to be declared in the colours.xml file in the Android Resources directory. I update the colour code _again_, and reload the app. Tiles now had proper colours! I ran the usual tests: placing tiles worked, ditto for swapping, but moving a placed tile crashed the whole show. So much for my excitement, for it was back to bug-fixing for me. The root of the problem was that the resetting of a grid button means setting the button background colour to white using the Android Color enum. This enum is NOT compatible with the colors.xml declarations since they use different methods. I toyed with using a conditional to check if a colour was passed to the button, but instead decided it would be easier to add my own 'black', 'white', and 'yellow' colours to the colour.xml and remove the Color enum entirely. As an aside, this was my first real Android and Kotlin project. Most of the stuff I can do is cobbled together from other languages and frameworks I know, and answers I can find online. This colour stuff took me a day and a half; I was not pleased with how much of a mess Android colour is to work with, and how rubbish it is that the Color enum is not compatible with color.xml nor can be used with colors defined using its own constructors for rendering to the display.

After squashing the last few display bugs, the game was finally playable. All that was left was to implement the main menu and the puzzle selector. The menu was pretty easy, though after the colour ordeal, I felt like I could do anything. The puzzle selector was a bit more complex. The request for puzzles from the server was a quick hit, but the list view needed more time since there isn't the facility to programmatically declare prototype cells like in UIKit. I gave it a bash in XML, but didn't get very far before I left for a two-week holiday abroad. In any case, the iOS equivalent page needs a lot of work, so I'm happy to leave that until I find a design and implementation that is decent.

## Holiday distractions

Going away for a while is great, but in between all the walking and sights and food, sometimes you need to stop and relax for an hour. Lucky for me, coding is quite relaxing! ~Un~fortunately, I didn't have my Android development environment with me, so I looked for a small project to pass the time. Cue "Psakse for MacOS", the hit puzzle game from Anachronistic Tech now on your Mac! I figured since the original project was built in Swift, the Mac port should not have been too stressful, and since UIKit doesn't exist on Mac, I would get to learn AppKit instead.

To point out a few things I learned, you can't just replace UI* with NS* for most UIKit classes, AppKit feels primitive compared to UIKit, and we're not developing for a mobile platform anymore. Starting at the top, while most UIKit classes have AppKit equivalents (prefixed with NS instead of UI), you can't just replace the prefix and hope it all works out; though the classes match up usually, the have different constructors, methods, and/or members, such that most of the UI code - primarily for buttons - had to be rewritten. Since most of the buttons were defined in for loops and had methods declared in an extension block, finding all the buttons to modify was quite simple. The tricky part was - surprise, surprise - colour.

I mentioned that AppKit seemed a bit primitive compared to UIKit. I won't say it's necessarily less powerful than UIKit, but it is much older (AppKit dates back to the 90s while UIKit was developed for iOS in the 2000s) and feels a bit clunkier to work with. For example, Buttons in UIKit are quite flexible. You can set a background colour, image, text label, you could curve to corners or add a border stroke by modifying the layer property, all just out of the box. AppKit buttons are more difficult to work with since the idea is that a developer says "I want a button," and Mac responds, "Here you go, we'll make it look like the rest of the system for you." It's good if you want a plain ol' button for your program, but not if you want to build a game.

To get around this, you modify the button's layer properties. For example:

```swift
let button = NSButton()
button.layer?.backgroundColor = CGColor.red
```

Notice the question mark on the layer member. This represents an optional and indicates that a layer of type CGLayer may not exist for this button. That probably sould have tipped me off, but it took me a while to realise that the reason for the optional is that the layer is NOT instantiated when the button is created. Why would it if Mac will do all the styling for you? It took me far too long to realise that the reason for this code not working was that you need to give the button a layer first.

```swift
let button = NSButton()
let layer = CGLayer()
layer.backgroundColor = CGColor.red
button.layer = layer
```

Without giving the button a layer first, the first code silently fails on the second line since there is no layer to change the background color of. Once I realised what was going on, I made a few quick fixes and the game quickly reached the playable state.

It pays to bear in mind the type of platform you're developing for. Psakse was designed to be a mobile game, and the source code reflects this. For example, we need to know the device dimensions. For iOS, this is a piece of cake:

```swift
let width = UIScreen.main.bounds.width
let height = UIScreen.main.bounds.height
```

How does this translate to a platform with resizable windows? For the game, I decided to have a fixed-size, non-resizable window such that we know the dimensions at all times. I could then get the dimensions when each view controller loaded and the rest of the code would work with few changes. The exception to this was the Grid class since I now had to pass the window dimensions to it as they are no longer globally accessible constants like UIScreen. 

After a few days chipping away for an hour a day at the project, I was almost at the end. All I had to do was wire up the transitions, or _segues_, between the different view controllers and build the puzzle selector. As with the Android version, I chose to skip the selector since it needs a facelift, so I focused on the segues. I replicated the iOS ones so I wouldn't have to rewrite a bunch of methods, and ran the app to test. The result was surprising: not only did using a segue open a new window to the destination view controller, it could open the same view controller multiple times! On iOS, you would never encounter this since there is only ever one 'window' open at a time. A desktop OS has no such restriction. I found a switch that disabled the opening of view controllers multiple times, but I couldn't spot such a setting for restricting the app to a single window, so I looked for answers online.

The results were disappointing at best. Most of the answers, if they weren't in Objective-C, were unhelpful, deprecated, or quite hacky. The best I could find was using a tab-view controller to hold all the view controllers in one window then hide the tab bar and switch tabs programmatically. That's right; the best way I could find was to use a _tabless tab-view controller_. This seemed unsatisfying and overly complex, so I was happy to leave it until after the holidays when I could be home and have more screen space for browser tabs.

## Conclusions

With the holidays over, it's back to Android to finish up "Psakse for Android". Having had time to reflect on it, I may have been a bit harsh in condemning Android development. My opinion that it's a mess (what with all the API version differences and incompatibilities with XML and programmatic UI and colour) is unlikely to change any time soon, though there is one point I feel I should make: putting all the layout, colours, and resources in XML seems like an interesting way of keeping things neat and sectioned away, but I feel like it gets in the way if you aren't building the specific type of app Android expects. Other than colour, the main problem I found when looking up solutions was that most examples were in XML which was not helpful for the exercise.

On the Mac front, things went a lot more smothly. Despite the issues, I've grown to appreciate AppKit. It's not UIKit by any means, but it's far more powerful than I would expect of a framework built 25 years ago for a different language. It has a lot of quirks, but I found that once I understood the purpose of AppKit and its intended use, it became easier to code. Like with Android, many online examples were in a different language (not XML, but Objective-C), but finding answers to problems was less painstaking than for Android.

Psakse for Android is available [here](https://github.com/AnachronisticTech/Psakse-Android), and Psakse for MacOS is available [here](https://github.com/AnachronisticTech/Psakse-MacOS); both will hopefully be completed and polished by mid-August once I've returned home. Please feel free to download and build them, and let me know if you encounter any difficulties or bugs. Thank you for putting up with this longer-than-usual post!